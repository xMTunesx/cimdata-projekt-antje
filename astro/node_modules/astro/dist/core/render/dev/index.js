import { fileURLToPath } from "url";
import { getStylesForURL } from "./css.js";
import { injectTags } from "./html.js";
import { resolveRenderers } from "./renderers.js";
import { errorHandler } from "./error.js";
import { getHmrScript } from "./hmr.js";
import { prependForwardSlash } from "../../path.js";
import { render as coreRender } from "../core.js";
import { createModuleScriptElementWithSrcSet } from "../ssr-element.js";
const svelteStylesRE = /svelte\?svelte&type=style/;
async function preload({ astroConfig, filePath, viteServer }) {
  const renderers = await resolveRenderers(viteServer, astroConfig);
  const mod = await viteServer.ssrLoadModule(fileURLToPath(filePath));
  return [renderers, mod];
}
async function render(renderers, mod, ssrOpts) {
  const { astroConfig, filePath, logging, mode, origin, pathname, route, routeCache, viteServer } = ssrOpts;
  const legacy = astroConfig.buildOptions.legacyBuild;
  const scripts = createModuleScriptElementWithSrcSet(!legacy && mod.hasOwnProperty("$$metadata") ? Array.from(mod.$$metadata.hoistedScriptPaths()) : []);
  if (mod.hasOwnProperty("$$metadata") && mode === "development" && !legacy) {
    scripts.add({
      props: { type: "module", src: "/@vite/client" },
      children: ""
    });
    scripts.add({
      props: { type: "module", src: new URL("../../../runtime/client/hmr.js", import.meta.url).pathname },
      children: ""
    });
  }
  let links = /* @__PURE__ */ new Set();
  if (!legacy) {
    [...getStylesForURL(filePath, viteServer)].forEach((href) => {
      if (mode === "development" && svelteStylesRE.test(href)) {
        scripts.add({
          props: { type: "module", src: href },
          children: ""
        });
      } else {
        links.add({
          props: {
            rel: "stylesheet",
            href,
            "data-astro-injected": true
          },
          children: ""
        });
      }
    });
  }
  let content = await coreRender({
    legacyBuild: astroConfig.buildOptions.legacyBuild,
    links,
    logging,
    markdownRender: astroConfig.markdownOptions.render,
    mod,
    origin,
    pathname,
    scripts,
    async resolve(s) {
      if (!astroConfig.buildOptions.legacyBuild) {
        const [, resolvedPath] = await viteServer.moduleGraph.resolveUrl(s);
        return "/@fs" + prependForwardSlash(resolvedPath);
      } else {
        return s;
      }
    },
    renderers,
    route,
    routeCache,
    site: astroConfig.buildOptions.site
  });
  if ((route == null ? void 0 : route.type) === "endpoint") {
    return content;
  }
  const tags = [];
  if (mode === "development" && legacy) {
    tags.push({
      tag: "script",
      attrs: { type: "module" },
      children: await getHmrScript(),
      injectTo: "head"
    });
  }
  if (legacy) {
    [...getStylesForURL(filePath, viteServer)].forEach((href) => {
      if (mode === "development" && svelteStylesRE.test(href)) {
        tags.push({
          tag: "script",
          attrs: { type: "module", src: href },
          injectTo: "head"
        });
      } else {
        tags.push({
          tag: "link",
          attrs: {
            rel: "stylesheet",
            href,
            "data-astro-injected": true
          },
          injectTo: "head"
        });
      }
    });
  }
  content = injectTags(content, tags);
  if (mode === "development" && astroConfig.buildOptions.legacyBuild) {
    const relativeURL = filePath.href.replace(astroConfig.projectRoot.href, "/");
    content = await viteServer.transformIndexHtml(relativeURL, content, pathname);
  }
  if (!/<!doctype html/i.test(content)) {
    content = "<!DOCTYPE html>\n" + content;
  }
  return content;
}
async function ssr(preloadedComponent, ssrOpts) {
  try {
    const [renderers, mod] = preloadedComponent;
    return await render(renderers, mod, ssrOpts);
  } catch (e) {
    await errorHandler(e, { viteServer: ssrOpts.viteServer, filePath: ssrOpts.filePath });
    throw e;
  }
}
export {
  preload,
  render,
  ssr
};
