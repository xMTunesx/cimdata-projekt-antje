var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _cache, _result, _slots;
import { bold } from "kleur/colors";
import { canonicalURL as getCanonicalURL } from "../util.js";
import { isCSSRequest } from "./dev/css.js";
import { isScriptRequest } from "./script.js";
import { renderSlot } from "../../runtime/server/index.js";
import { warn } from "../logger.js";
class Slots {
  constructor(result, slots) {
    __privateAdd(this, _cache, /* @__PURE__ */ new Map());
    __privateAdd(this, _result, void 0);
    __privateAdd(this, _slots, void 0);
    __privateSet(this, _result, result);
    __privateSet(this, _slots, slots);
    if (slots) {
      for (const key of Object.keys(slots)) {
        if (this[key] !== void 0) {
          throw new Error(`Unable to create a slot named "${key}". "${key}" is a reserved slot name!
Please update the name of this slot.`);
        }
        Object.defineProperty(this, key, {
          get() {
            return true;
          },
          enumerable: true
        });
      }
    }
  }
  has(name) {
    if (!__privateGet(this, _slots))
      return false;
    return Boolean(__privateGet(this, _slots)[name]);
  }
  async render(name) {
    if (!__privateGet(this, _slots))
      return void 0;
    if (__privateGet(this, _cache).has(name)) {
      const result = __privateGet(this, _cache).get(name);
      return result;
    }
    if (!this.has(name))
      return void 0;
    const content = await renderSlot(__privateGet(this, _result), __privateGet(this, _slots)[name]).then((res) => res != null ? res.toString() : res);
    __privateGet(this, _cache).set(name, content);
    return content;
  }
}
_cache = new WeakMap();
_result = new WeakMap();
_slots = new WeakMap();
function createResult(args) {
  const { legacyBuild, origin, markdownRender, params, pathname, renderers, resolve, site: buildOptionsSite } = args;
  const result = {
    styles: /* @__PURE__ */ new Set(),
    scripts: args.scripts ?? /* @__PURE__ */ new Set(),
    links: args.links ?? /* @__PURE__ */ new Set(),
    createAstro(astroGlobal, props, slots) {
      const site = new URL(origin);
      const url = new URL("." + pathname, site);
      const canonicalURL = getCanonicalURL("." + pathname, buildOptionsSite || origin);
      const astroSlots = new Slots(result, slots);
      return {
        __proto__: astroGlobal,
        props,
        request: {
          canonicalURL,
          params,
          url
        },
        resolve(path) {
          if (!legacyBuild) {
            let extra = `This can be replaced with a dynamic import like so: await import("${path}")`;
            if (isCSSRequest(path)) {
              extra = `It looks like you are resolving styles. If you are adding a link tag, replace with this:

<style global>
@import "${path}";
</style>
`;
            } else if (isScriptRequest(path)) {
              extra = `It looks like you are resolving scripts. If you are adding a script tag, replace with this:

<script type="module" src={(await import("${path}?url")).default}><\/script>

or consider make it a module like so:

<script type="module" hoist>
	import MyModule from "${path}";
<\/script>
`;
            }
            warn(args.logging, `deprecation`, `${bold("Astro.resolve()")} is deprecated. We see that you are trying to resolve ${path}.
${extra}`);
            return "";
          }
          return astroGlobal.resolve(path);
        },
        slots: astroSlots,
        async privateRenderMarkdownDoNotUse(content, opts) {
          let [mdRender, renderOpts] = markdownRender;
          let parser = null;
          if (Array.isArray(mdRender)) {
            renderOpts = mdRender[1];
            mdRender = mdRender[0];
          }
          if (typeof mdRender === "string") {
            const mod = await import(mdRender);
            parser = mod.default;
          } else if (mdRender instanceof Promise) {
            const mod = await mdRender;
            parser = mod.default;
          } else if (typeof mdRender === "function") {
            parser = mdRender;
          } else {
            throw new Error("No Markdown parser found.");
          }
          const { code } = await parser(content, __spreadValues(__spreadValues({}, renderOpts), opts ?? {}));
          return code;
        }
      };
    },
    resolve,
    _metadata: {
      renderers,
      pathname,
      legacyBuild
    }
  };
  return result;
}
export {
  createResult
};
