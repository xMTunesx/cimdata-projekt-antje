var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
import { renderEndpoint, renderHead, renderToString } from "../../runtime/server/index.js";
import { getParams } from "../routing/index.js";
import { createResult } from "./result.js";
import { findPathItemByKey, callGetStaticPaths } from "./route-cache.js";
var GetParamsAndPropsError = /* @__PURE__ */ ((GetParamsAndPropsError2) => {
  GetParamsAndPropsError2[GetParamsAndPropsError2["NoMatchingStaticPath"] = 0] = "NoMatchingStaticPath";
  return GetParamsAndPropsError2;
})(GetParamsAndPropsError || {});
async function getParamsAndProps(opts) {
  const { logging, mod, route, routeCache, pathname } = opts;
  let params = {};
  let pageProps;
  if (route && !route.pathname) {
    if (route.params.length) {
      const paramsMatch = route.pattern.exec(pathname);
      if (paramsMatch) {
        params = getParams(route.params)(paramsMatch);
      }
    }
    let routeCacheEntry = routeCache.get(route);
    if (!routeCacheEntry) {
      routeCacheEntry = await callGetStaticPaths(mod, route, true, logging);
      routeCache.set(route, routeCacheEntry);
    }
    const matchedStaticPath = findPathItemByKey(routeCacheEntry.staticPaths, params);
    if (!matchedStaticPath) {
      return 0 /* NoMatchingStaticPath */;
    }
    pageProps = matchedStaticPath.props ? __spreadValues({}, matchedStaticPath.props) : {};
  } else {
    pageProps = {};
  }
  return [params, pageProps];
}
async function render(opts) {
  const { legacyBuild, links, logging, origin, markdownRender, mod, pathname, scripts, renderers, resolve, route, routeCache, site } = opts;
  const paramsAndPropsRes = await getParamsAndProps({
    logging,
    mod,
    route,
    routeCache,
    pathname
  });
  if (paramsAndPropsRes === 0 /* NoMatchingStaticPath */) {
    throw new Error(`[getStaticPath] route pattern matched, but no matching static path found. (${pathname})`);
  }
  const [params, pageProps] = paramsAndPropsRes;
  if ((route == null ? void 0 : route.type) === "endpoint") {
    return renderEndpoint(mod, params);
  }
  const Component = await mod.default;
  if (!Component)
    throw new Error(`Expected an exported Astro component but received typeof ${typeof Component}`);
  if (!Component.isAstroComponentFactory)
    throw new Error(`Unable to SSR non-Astro component (${route == null ? void 0 : route.component})`);
  const result = createResult({
    legacyBuild,
    links,
    logging,
    markdownRender,
    origin,
    params,
    pathname,
    resolve,
    renderers,
    site,
    scripts
  });
  let html = await renderToString(result, Component, pageProps, null);
  if (html.indexOf("<!--astro:head:injected-->") == -1) {
    html = await renderHead(result) + html;
  }
  html = html.replace("<!--astro:head:injected-->", "");
  if (!legacyBuild && !/<!doctype html/i.test(html)) {
    html = "<!DOCTYPE html>\n" + html;
  }
  return html;
}
export {
  GetParamsAndPropsError,
  getParamsAndProps,
  render
};
