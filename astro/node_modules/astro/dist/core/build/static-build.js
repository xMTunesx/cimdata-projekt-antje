var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import fs from "fs";
import npath from "path";
import { fileURLToPath } from "url";
import glob from "fast-glob";
import * as vite from "vite";
import { debug, error } from "../../core/logger.js";
import { prependForwardSlash, appendForwardSlash } from "../../core/path.js";
import { emptyDir, removeDir, resolveDependency } from "../../core/util.js";
import { createBuildInternals } from "../../core/build/internal.js";
import { rollupPluginAstroBuildCSS } from "../../vite-plugin-build-css/index.js";
import { vitePluginHoistedScripts } from "./vite-plugin-hoisted-scripts.js";
import { serializeRouteData } from "../routing/index.js";
import { render } from "../render/core.js";
import { createLinkStylesheetElementSet, createModuleScriptElementWithSrcSet } from "../render/ssr-element.js";
const MAX_CONCURRENT_RENDERS = 1;
const STATUS_CODE_PAGES = /* @__PURE__ */ new Set(["/404", "/500"]);
function addPageName(pathname, opts) {
  opts.pageNames.push(pathname.replace(/\/?$/, "/").replace(/^\//, ""));
}
function rootRelativeFacadeId(facadeId, astroConfig) {
  return facadeId.slice(fileURLToPath(astroConfig.projectRoot).length);
}
function chunkIsPage(astroConfig, output, internals) {
  if (output.type !== "chunk") {
    return false;
  }
  const chunk = output;
  if (chunk.facadeModuleId) {
    const facadeToEntryId = prependForwardSlash(rootRelativeFacadeId(chunk.facadeModuleId, astroConfig));
    return internals.entrySpecifierToBundleMap.has(facadeToEntryId);
  }
  return false;
}
function* throttle(max, inPaths) {
  let tmp = [];
  let i = 0;
  for (let path of inPaths) {
    tmp.push(path);
    if (i === max) {
      yield tmp;
      tmp.length = 0;
      i = 0;
    } else {
      i++;
    }
  }
  if (tmp.length) {
    yield tmp;
  }
}
function getByFacadeId(facadeId, map) {
  return map.get(facadeId) || map.get(facadeId.replace(/\//g, "\\"));
}
async function staticBuild(opts) {
  const { allPages, astroConfig } = opts;
  const staticMode = !astroConfig.buildOptions.experimentalSsr;
  const pageInput = /* @__PURE__ */ new Set();
  const jsInput = /* @__PURE__ */ new Set();
  const facadeIdToPageDataMap = /* @__PURE__ */ new Map();
  const polyfills = getRenderers(opts).flatMap((renderer) => {
    return (renderer.polyfills || []).concat(renderer.hydrationPolyfills || []);
  });
  for (const polyfill of polyfills) {
    jsInput.add(polyfill);
  }
  const internals = createBuildInternals();
  for (const [component, pageData] of Object.entries(allPages)) {
    const astroModuleURL = new URL("./" + component, astroConfig.projectRoot);
    const astroModuleId = prependForwardSlash(component);
    if (pageData.route.type === "page") {
      const [renderers, mod] = pageData.preload;
      const metadata = mod.$$metadata;
      const topLevelImports = /* @__PURE__ */ new Set([
        ...metadata.hydratedComponentPaths(),
        ...metadata.clientOnlyComponentPaths(),
        ...metadata.hydrationDirectiveSpecifiers(),
        ...renderers.filter((renderer) => !!renderer.source).map((renderer) => renderer.source)
      ]);
      const hoistedScripts = new Set(metadata.hoistedScriptPaths());
      if (hoistedScripts.size) {
        const moduleId = npath.posix.join(astroModuleId, "hoisted.js");
        internals.hoistedScriptIdToHoistedMap.set(moduleId, hoistedScripts);
        topLevelImports.add(moduleId);
      }
      for (const specifier of topLevelImports) {
        jsInput.add(specifier);
      }
    }
    pageInput.add(astroModuleId);
    facadeIdToPageDataMap.set(fileURLToPath(astroModuleURL), pageData);
  }
  emptyDir(astroConfig.dist, new Set(".git"));
  const ssrResult = await ssrBuild(opts, internals, pageInput);
  await clientBuild(opts, internals, jsInput);
  if (staticMode) {
    await generatePages(ssrResult, opts, internals, facadeIdToPageDataMap);
    await cleanSsrOutput(opts);
  } else {
    await generateManifest(ssrResult, opts, internals);
    await ssrMoveAssets(opts);
  }
}
async function ssrBuild(opts, internals, input) {
  const { astroConfig, viteConfig } = opts;
  const ssr = astroConfig.buildOptions.experimentalSsr;
  const out = ssr ? getServerRoot(astroConfig) : getOutRoot(astroConfig);
  return await vite.build({
    logLevel: "warn",
    mode: "production",
    build: __spreadProps(__spreadValues({}, viteConfig.build), {
      emptyOutDir: false,
      manifest: ssr,
      outDir: fileURLToPath(out),
      ssr: true,
      rollupOptions: {
        input: Array.from(input),
        output: {
          format: "esm",
          entryFileNames: "[name].[hash].mjs",
          chunkFileNames: "chunks/[name].[hash].mjs",
          assetFileNames: "assets/[name].[hash][extname]"
        }
      },
      target: "esnext",
      minify: false,
      polyfillModulePreload: false,
      reportCompressedSize: false
    }),
    plugins: [
      vitePluginNewBuild(input, internals, "mjs"),
      rollupPluginAstroBuildCSS({
        internals
      }),
      ...viteConfig.plugins || []
    ],
    publicDir: ssr ? false : viteConfig.publicDir,
    root: viteConfig.root,
    envPrefix: "PUBLIC_",
    server: viteConfig.server,
    base: astroConfig.buildOptions.site ? new URL(astroConfig.buildOptions.site).pathname : "/",
    ssr: viteConfig.ssr
  });
}
async function clientBuild(opts, internals, input) {
  const { astroConfig, viteConfig } = opts;
  if (!input.size) {
    return null;
  }
  const out = astroConfig.buildOptions.experimentalSsr ? getClientRoot(astroConfig) : getOutRoot(astroConfig);
  return await vite.build({
    logLevel: "warn",
    mode: "production",
    build: {
      emptyOutDir: false,
      minify: "esbuild",
      outDir: fileURLToPath(out),
      rollupOptions: {
        input: Array.from(input),
        output: {
          format: "esm",
          entryFileNames: "[name].[hash].js",
          chunkFileNames: "chunks/[name].[hash].js",
          assetFileNames: "assets/[name].[hash][extname]"
        },
        preserveEntrySignatures: "exports-only"
      },
      target: "esnext"
    },
    plugins: [
      vitePluginNewBuild(input, internals, "js"),
      vitePluginHoistedScripts(astroConfig, internals),
      rollupPluginAstroBuildCSS({
        internals
      }),
      ...viteConfig.plugins || []
    ],
    publicDir: viteConfig.publicDir,
    root: viteConfig.root,
    envPrefix: "PUBLIC_",
    server: viteConfig.server,
    base: appendForwardSlash(astroConfig.buildOptions.site ? new URL(astroConfig.buildOptions.site).pathname : "/")
  });
}
function getRenderers(opts) {
  const pageData = Object.values(opts.allPages)[0];
  const viteLoadedRenderers = pageData.preload[0];
  return viteLoadedRenderers;
}
async function collectRenderers(opts) {
  const viteLoadedRenderers = getRenderers(opts);
  const renderers = await Promise.all(viteLoadedRenderers.map(async (r) => {
    const mod = await import(resolveDependency(r.serverEntry, opts.astroConfig));
    return Object.create(r, {
      ssr: {
        value: mod.default
      }
    });
  }));
  return renderers;
}
async function generatePages(result, opts, internals, facadeIdToPageDataMap) {
  debug("build", "Finish build. Begin generating.");
  const renderers = await collectRenderers(opts);
  for (let output of result.output) {
    if (chunkIsPage(opts.astroConfig, output, internals)) {
      await generatePage(output, opts, internals, facadeIdToPageDataMap, renderers);
    }
  }
}
async function generatePage(output, opts, internals, facadeIdToPageDataMap, renderers) {
  const { astroConfig } = opts;
  let url = new URL("./" + output.fileName, getOutRoot(astroConfig));
  const facadeId = output.facadeModuleId;
  let pageData = getByFacadeId(facadeId, facadeIdToPageDataMap);
  if (!pageData) {
    throw new Error(`Unable to find a PageBuildData for the Astro page: ${facadeId}. There are the PageBuildDatas we have ${Array.from(facadeIdToPageDataMap.keys()).join(", ")}`);
  }
  const linkIds = getByFacadeId(facadeId, internals.facadeIdToAssetsMap) || [];
  const hoistedId = getByFacadeId(facadeId, internals.facadeIdToHoistedEntryMap) || null;
  let compiledModule = await import(url.toString());
  const generationOptions = {
    pageData,
    internals,
    linkIds,
    hoistedId,
    mod: compiledModule,
    renderers
  };
  const renderPromises = [];
  for (const paths of throttle(MAX_CONCURRENT_RENDERS, pageData.paths)) {
    for (const path of paths) {
      renderPromises.push(generatePath(path, opts, generationOptions));
    }
    await Promise.all(renderPromises);
    renderPromises.length = 0;
  }
}
async function generatePath(pathname, opts, gopts) {
  const { astroConfig, logging, origin, routeCache } = opts;
  const { mod, internals, linkIds, hoistedId, pageData, renderers } = gopts;
  if (pageData.route.type === "page") {
    addPageName(pathname, opts);
  }
  debug("build", `Generating: ${pathname}`);
  const site = astroConfig.buildOptions.site;
  const links = createLinkStylesheetElementSet(linkIds.reverse(), site);
  const scripts = createModuleScriptElementWithSrcSet(hoistedId ? [hoistedId] : [], site);
  try {
    const html = await render({
      legacyBuild: false,
      links,
      logging,
      markdownRender: astroConfig.markdownOptions.render,
      mod,
      origin,
      pathname,
      scripts,
      renderers,
      async resolve(specifier) {
        const hashedFilePath = internals.entrySpecifierToBundleMap.get(specifier);
        if (typeof hashedFilePath !== "string") {
          throw new Error(`Cannot find the built path for ${specifier}`);
        }
        const relPath = npath.posix.relative(pathname, "/" + hashedFilePath);
        const fullyRelativePath = relPath[0] === "." ? relPath : "./" + relPath;
        return fullyRelativePath;
      },
      route: pageData.route,
      routeCache,
      site: astroConfig.buildOptions.site
    });
    const outFolder = getOutFolder(astroConfig, pathname, pageData.route.type);
    const outFile = getOutFile(astroConfig, outFolder, pathname, pageData.route.type);
    await fs.promises.mkdir(outFolder, { recursive: true });
    await fs.promises.writeFile(outFile, html, "utf-8");
  } catch (err) {
    error(opts.logging, "build", `Error rendering:`, err);
  }
}
async function generateManifest(result, opts, internals) {
  const { astroConfig, manifest } = opts;
  const manifestFile = new URL("./manifest.json", getServerRoot(astroConfig));
  const inputManifestJSON = await fs.promises.readFile(manifestFile, "utf-8");
  const data = JSON.parse(inputManifestJSON);
  const rootRelativeIdToChunkMap = /* @__PURE__ */ new Map();
  for (const output of result.output) {
    if (chunkIsPage(astroConfig, output, internals)) {
      const chunk = output;
      if (chunk.facadeModuleId) {
        const id = rootRelativeFacadeId(chunk.facadeModuleId, astroConfig);
        rootRelativeIdToChunkMap.set(id, chunk);
      }
    }
  }
  const routes = [];
  for (const routeData of manifest.routes) {
    const componentPath = routeData.component;
    const entry = data[componentPath];
    if (!rootRelativeIdToChunkMap.has(componentPath)) {
      throw new Error("Unable to find chunk for " + componentPath);
    }
    const chunk = rootRelativeIdToChunkMap.get(componentPath);
    const facadeId = chunk.facadeModuleId;
    const links = getByFacadeId(facadeId, internals.facadeIdToAssetsMap) || [];
    const hoistedScript = getByFacadeId(facadeId, internals.facadeIdToHoistedEntryMap);
    const scripts = hoistedScript ? [hoistedScript] : [];
    routes.push({
      file: entry == null ? void 0 : entry.file,
      links,
      scripts,
      routeData: serializeRouteData(routeData)
    });
  }
  const ssrManifest = {
    routes,
    site: astroConfig.buildOptions.site,
    markdown: {
      render: astroConfig.markdownOptions.render
    },
    renderers: astroConfig.renderers,
    entryModules: Object.fromEntries(internals.entrySpecifierToBundleMap.entries())
  };
  const outputManifestJSON = JSON.stringify(ssrManifest, null, "  ");
  await fs.promises.writeFile(manifestFile, outputManifestJSON, "utf-8");
}
function getOutRoot(astroConfig) {
  return new URL("./", astroConfig.dist);
}
function getServerRoot(astroConfig) {
  const rootFolder = getOutRoot(astroConfig);
  const serverFolder = new URL("./server/", rootFolder);
  return serverFolder;
}
function getClientRoot(astroConfig) {
  const rootFolder = getOutRoot(astroConfig);
  const serverFolder = new URL("./client/", rootFolder);
  return serverFolder;
}
function getOutFolder(astroConfig, pathname, routeType) {
  const outRoot = getOutRoot(astroConfig);
  switch (routeType) {
    case "endpoint":
      return new URL("." + appendForwardSlash(npath.dirname(pathname)), outRoot);
    case "page":
      switch (astroConfig.buildOptions.pageUrlFormat) {
        case "directory": {
          if (STATUS_CODE_PAGES.has(pathname)) {
            return new URL("." + appendForwardSlash(npath.dirname(pathname)), outRoot);
          }
          return new URL("." + appendForwardSlash(pathname), outRoot);
        }
        case "file": {
          return new URL("." + appendForwardSlash(npath.dirname(pathname)), outRoot);
        }
      }
  }
}
function getOutFile(astroConfig, outFolder, pathname, routeType) {
  switch (routeType) {
    case "endpoint":
      return new URL(npath.basename(pathname), outFolder);
    case "page":
      switch (astroConfig.buildOptions.pageUrlFormat) {
        case "directory": {
          if (STATUS_CODE_PAGES.has(pathname)) {
            const baseName = npath.basename(pathname);
            return new URL("./" + (baseName || "index") + ".html", outFolder);
          }
          return new URL("./index.html", outFolder);
        }
        case "file": {
          const baseName = npath.basename(pathname);
          return new URL("./" + (baseName || "index") + ".html", outFolder);
        }
      }
  }
}
async function cleanSsrOutput(opts) {
  const files = await glob("**/*.mjs", {
    cwd: fileURLToPath(opts.astroConfig.dist)
  });
  await Promise.all(files.map(async (filename) => {
    const url = new URL(filename, opts.astroConfig.dist);
    await fs.promises.rm(url);
  }));
}
async function ssrMoveAssets(opts) {
  const { astroConfig } = opts;
  const serverRoot = getServerRoot(astroConfig);
  const clientRoot = getClientRoot(astroConfig);
  const serverAssets = new URL("./assets/", serverRoot);
  const clientAssets = new URL("./assets/", clientRoot);
  const files = await glob("assets/**/*", {
    cwd: fileURLToPath(serverRoot)
  });
  await fs.promises.mkdir(clientAssets, { recursive: true });
  await Promise.all(files.map(async (filename) => {
    const currentUrl = new URL(filename, serverRoot);
    const clientUrl = new URL(filename, clientRoot);
    return fs.promises.rename(currentUrl, clientUrl);
  }));
  await removeDir(serverAssets);
}
function vitePluginNewBuild(input, internals, ext) {
  return {
    name: "@astro/rollup-plugin-new-build",
    config(config, options) {
      var _a;
      const extra = {};
      const noExternal = [], external = [];
      if (options.command === "build" && ((_a = config.build) == null ? void 0 : _a.ssr)) {
        noExternal.push("astro");
        external.push("shiki");
      }
      extra.ssr = {
        external,
        noExternal
      };
      return extra;
    },
    configResolved(resolvedConfig) {
      const plugins = resolvedConfig.plugins;
      const viteAsset = plugins.find((p) => p.name === "vite:asset");
      if (viteAsset) {
        delete viteAsset.generateBundle;
      }
    },
    async generateBundle(_options, bundle) {
      const promises = [];
      const mapping = /* @__PURE__ */ new Map();
      for (const specifier of input) {
        promises.push(this.resolve(specifier).then((result) => {
          if (result) {
            mapping.set(result.id, specifier);
          }
        }));
      }
      await Promise.all(promises);
      for (const [, chunk] of Object.entries(bundle)) {
        if (chunk.type === "chunk" && chunk.facadeModuleId && mapping.has(chunk.facadeModuleId)) {
          const specifier = mapping.get(chunk.facadeModuleId);
          internals.entrySpecifierToBundleMap.set(specifier, chunk.fileName);
        }
      }
    }
  };
}
export {
  staticBuild,
  vitePluginNewBuild
};
